day02

Условные операторы/ Conditional Statements.

- это позволяет нам запускать тот или иной блок кода на основе условия.
Например:

/*

    if (condition) 
    {
    statement-block;
    }

*/

Это пример условного оператора в С++.
При оценке условий, оно может быть или TRUE или FALSE...
Если условие оцениться как TRUE, то будет выполнен блок операторов.
statement-block может быть в несколько строк и его заключаем в фигурные скобки.

/*

    if (condition) {
    statement-block;
    }
    else {
    else-statement-block   // этот блок операторов выполняется если условие оценивается как FALSE.
    }

*/

Тернарный условный оператор.
Это простой способ выбора значения на основе условия.
Например:
auto s = x > y ? "yes" : "no"; 
"?" - отделяет условие от результатов. Если условие true то вернет 1 значение. А если false то второе. 
Присваивает одно из этих значений "yes" или "no";
Затем можно вывести его так:
cout << format(" answer is {}\n ", s);



while.

    while (condition)
    {
    statement-block;
    }

-здесь блок операторов будет выполняться до тех пор пока условие не станет ложиным.
в отличии от if после выполнения блока операторов поток возвращается обратно к условию и это создает цикл.
Цикл заканчивается только тогда, когда условие становится false.

Схематически это так:
1. Сначала проверяется condition
2. Если true → выполняется блок
3. Потом снова проверяется condition
4. И так по кругу
5. Если стало false → выход из цикла.

Проверка происходит ДО выполнения блока.Если условие сразу false — блок не выполнится ни разу.

/*

    int i = 0;

    while (i < 3)
    {
    std::cout << i << "\n";
    ++i;
    }


*/

Вывод:
0
1
2

почему так? Потому что, когда i станет 3, то  i < 3 будет false и цикл завершится.

if проверяет условие один раз.



do while.

/*

    do
    {
    statement_block;
    }
    while (condition);

*/

Cхематично:
1. Сначала выполняется блок
2. Потом проверяется условие
3. Если true → повторяем
4. Если false → выходим

Главное отличие:
Блок выполнится минимум один раз.


оператор break немедленно завершает цикл.
/*
    int i = 0;

    while (i < 10)
    {
    if (i == 5)
    break;

    std::cout << i << "\n";
    ++i;
}

*/
Когда i == 5 → выполняется break → цикл завершён.


continue.
пропускает оставшийся код текущей итерации
и возвращает управление к проверке условия.

Цикл НЕ заканчивается.

/*
    int i = 0;

    while (i < 6)
    {
    ++i;

    if (i == 3)
        continue;

    std::cout << i << "\n";
}

*/

Когда i == 3, continue пропускает cout и цикл идёт дальше...
Пропускает текущую итерацию простыми словами...





Цикл for.
Есть два вида for:
1. В стиле C.
2. В стиле С++

Цикл for похож на while с элементами управления для инициализации и увеличения индекса.
Существует три выражения управления циклом.
1. Инициалитор. int i {0};
2. Условие. i < 5;
3. Инкремент ++i;


Примеры:
/*

    #include <format>
    #include <iostream>

    using std::format;
    using std::cout;

    int main() {
    const char string[] {"string"};

    for (auto* p = string; *p; ++p) {
        cout << format("char is {}\n", *p);
    }
    }

*/
Здесь сделал тоже самое но с помощью указателя, for (auto* p = string; *p; ++p).
Вместо индекса auto* p = string; инициализировал значинаем строкового массива, после чего значением массива фактически является его адрес.
Таким образом указатель инициализируется адресом массива. 


/*
    
    #include <format>
    #include <iostream>

    using std::format;
    using std::cout;

    int main() {
    const char string[] {"string"}; 

    for (int i {0}; string[i]; ++i) {
        cout << format("element {} is {}\n", i, string[i]);
    }
    }

*/

Здесь вместо массива из примера for.cpp я написал const char string[] {"string"}; 
В условии указал string[i];




Range - for.
/* 

    for (тип переменная : контейнер)
    {
    // тело цикла
    }

*/
Это взять каждый элемент из контейнера по очереди и положи его в переменную.
На примере массива:

/*

    int arr[] = {1, 2, 3, 4};

    for (int value : arr)
    {
    std::cout << value << "\n";
    }

*/
arr — диапазон (range), a value — текущий элемент.



Функции. 

/*

    #include <format>
    #include <iostream>

    using std::format;
    using std::cout;

    void func() {
    cout << "this is func()\n";
    }

    int main()
    {
    cout << "this is main()\n";
    func(); //вызов ф-ции
    }

//содержимое в теле ф-ции {} говорит о том, что это за ф-ция.
// сначала запускается содержимое main, потом вызов ф-ции func() происходит и 1 ф-ция выводит инструкцию 2ой ф-ции void.

*/

теперь добавим параметры.
Пример:

/*
    
    #include <iostream>


    using std::cout;
    using std::format;

    void func(int a)    
    {
    cout << format("a is {}\n", a);
    }

    int main()
    {
    cout << "this is main()\n";
    func(42);
    }
*/

Мы можем добавлять и несколько параметров и передавать несколько значений ф-ции.

/*
    
    #include <iostream>


    using std::cout;
    using std::format;

    void func(int a, const  char* s)
    {
    cout << format("a is {} {}\n", a, s);
    }

    int main()
    {
    cout << "this is main()\n";
    func(42, "forty-two");
    }

*/

Итак...я передал 2 значения func(42, "forty-two"); в ф-цию. Выбираются они в ф-ции с помощью (int a, const  char* s)
И вывожу их используя эти переменные: a, s в cout << format("a is {} {}\n", a, s);

Ф-ция также может возвращать значение. 
Просто для этого нужно указать тип который нужно вернуть. Вместо void сделать int например. и в конце добавить return и добавить выражение: retuen a * 2;
А внизу вместо func(42, "forty-two"); можно сказать так: auto x = func(42, "forty-two"); и добавить вывод: cout << format("x is {}\n", x); 42 умножит на 2.
 
Ф-ция может возвращать только одно значение. 