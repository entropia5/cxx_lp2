#include <iostream>

int main() {
    signed short x = 32767; // Максимум для short
    x = x + 1; 
    std::cout << "32767 + 1 = " << x << std::endl; 

    unsigned short y = 65535; // Максимум для unsigned short
    y = y + 1;
    std::cout << "65535 + 1 = " << y << std::endl;

    x = x + 1; // было -32768
std::cout << "-32768 + 1 = " << x << std::endl; // выведет -32767, число начнет «расти» из глубокого минуса обратно к нулю.

    return 0;
}



//В signed уйдет в самый большой минус, а в unsigned превратится в ноль. произошло переполнение когда уперся в потолок памяти, прибавив 1 к макс числу.

//unsigned short. y = 65535. В двоичной системе (16 бит) это выглядит так: 1111 1111 1111 1111. Прибавил 1.
//Компьютер пытается сделать число 1 0000 0000 0000 0000. Но у типа short всего 16 ячеек. Лишняя единица слева просто «выпадает» из памяти, потому что ей негде храниться. 
//Итог: В ячейках остаются одни нули. Поэтому 65535 + 1 = 0

//signed short. Почему 32767 + 1 превращается в -32768?
//Компьютер использует систему Two's Complement (дополнительный код), чтобы различать плюс и минус.

//Самый левый бит — это знаковый бит.
//Если он 0 — число положительное.
//Если он 1 — число отрицательное.

//32767 в битах: 0111 1111 1111 1111 (первый бит 0, значит это плюс). Прибавил 1.
//Получаем: 1000 0000 0000 0000.
//Теперь первый бит стал равен 1! Для процессора это мгновенный сигнал: «Так, теперь это отрицательное число».
//По правилам двоичной логики комбинация 1000... соответствует самому маленькому возможному числу в этом типе — -32768.



