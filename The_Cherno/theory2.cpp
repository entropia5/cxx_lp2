/*переменная - Это именованная ячейка памяти в которой хранится значение

тип данных определяет размер памяти. Контекст определяет что мы видим на эркане - число или букву.

имя
тип
адрес
значение

Тип	                   Что хранит              	                    Пример
int	                      целые числа	                            int a = 5;
double	                дробные	                                double pi = 3.14;
char	                oдин символ	                             char c = 'A';
bool	                логическое	                              bool ok = true;
std::string	               строки	                               std::string s = "hi";

В C++ есть иерархия типов по «весу» (количеству байт и точности). Чем выше тип в списке, тем больше данных он может хранить:

long double
double
float
long long
long
int
short
char


Объявление и инициализация:
int x;        // объявление - память ещё не инициализирована
int y = 10;   // инициализация - и переменная получает значение

Неинициализированная переменная - опасна (мусор в памяти).

Объём памяти и значение (по умолчанию)
int = 4 байта (обычно)
double = 8 байт
char = 1 байт



Область видимости (scope)

Переменные живут там, где их объявили:
{
    int a = 5;
} // a больше не существует тут
Если переменная объявлена в функции — она локальна этой функции.


Константы
const int DAYS = 7;

Теперь DAYS - константа:
попытка DAYS = 5; вызовет ошибку компиляции. 


«Сужение типов» (Narrowing)

int x = 7.9; // Компилятор молча "откусит" дробную часть. x будет равен 7.

в новом стиле int x {7.9}; // ОШИБКА компиляции!
Использование фигурных скобок заставляет компилятор проверить: «А влезет ли значение в этот тип без потерь?». Если нет — программа просто не скомпилируется.

Есть такая забавная штука в C++, называется Most Vexing Parse (самый досадный разбор). Иногда, когда ты объявляешь переменную со скобками (), компилятор думает, что ты объявляешь функцию.

int a(); — Компилятор думает: «О, это функция a, которая возвращает int».
int a{}; — Компилятор точно знает: «Это переменная a, равная нулю».

int x = 5; — Олдскул, разрешает опасно сужать типы.
int x{5}; — Современный стандарт, защищает от ошибок.

unsigned short (без знака). Все 16 бит заняты числом. Формула простая: 2 в степени 16 =65536. Так как мы начинаем считать с нуля, диапазон будет от 0 до 65 535.
short (со знаком, по умолчанию). Один бит забирает «минус». Остается 15 бит под само число. 2 в степени 15=32768. Диапазон делится пополам: от -32 768 до 32 767.




Стек (stack) и куча (heap) — это два способа, как компьютер хранит данные в памяти. Разница во времени жизни. 
Стек - автоматически управляется компилятором, куча вручную, new/ delete, Время жизни в стеке - пока функция выполняется, а в куче - пока не delete

void example() {
    int a = 10;          // в стеке
    int* b = new int(20); // в куче
} // a автоматически уничтожен, но b не уничтожен → утечка




int* ptr = new int; // выделяем в куче
*ptr = 42;
delete ptr;        // освобождаем

здесь new int → запрашивает память у ОС (куча)
ptr хранится в стеке, но само число — в куче
delete → память освобождена

в стеке так.
void foo() {
    int x = 5;    // x в стеке
}
Вход в функцию → выделяется место под x
Выход из функции → память освобождается автоматически




*/